HWND :: void *mut
HANDLE :: void *mut
HINSTANCE :: HANDLE
HICON :: HANDLE
HCURSOR :: HICON
HBRUSH :: HANDLE

MB_OK :: 0 as u32
FILE_SHARE_READ :: 1 as DWORD

fn INVALID_HANDLE_VALUE(): HANDLE {
    -1 as isize as usize as HANDLE
}
DWORD :: u32
UINT :: u32
UINT_PTR :: usize
LONG_PTR :: isize
STD_INPUT_HANDLE :: (-10) as i32 as DWORD
STD_OUTPUT_HANDLE :: (-11) as i32 as DWORD
STD_ERROR_HANDLE :: (-12) as i32 as DWORD
BOOL :: i32
TRUE :: 1
FALSE :: 0

GENERIC_READ :: 2147483648 as DWORD
GENERIC_WRITE :: 1073741824 as DWORD

CREATE_ALWAYS :: 2 as DWORD
CREATE_NEW :: 1 as DWORD
OPEN_ALWAYS :: 4 as DWORD
OPEN_EXISTING :: 3 as DWORD
TRUNCATE_EXISTING :: 5 as DWORD

FILE_ATTRIBUTE_NORMAL :: 128 as DWORD

WPARAM :: UINT_PTR
LPARAM :: LONG_PTR
LRESULT :: LONG_PTR

// it is not currently possible to have constant pointers, which is why this is a function for now
fn NULL(): void *mut { 0 as usize as void *mut }

SECURITY_ATTRIBUTES :: struct {
    nLength: DWORD
    lpSecurityDescriptor: void *mut
    bInheritHandle: BOOL
}

OVERLAPPED :: struct {}

kernel32 :: extern_mod("kernel32.dll") {
    fn GetStdHandle(nStdHandle: DWORD): HANDLE
    fn WriteConsoleA(hConsoleOutput: HANDLE, lpBuffer: void*, nNumberOfCharsToWrite: DWORD, lpNumberOfCharsWritten: DWORD *mut, lpReserved: void *mut): BOOL
    fn ReadConsoleA(hConsoleInput: HANDLE, lpBuffer: void *mut, nNumberOfCharsToRead: DWORD, lpNumberOfCharsRead: DWORD *mut, pInputControl: void *mut): BOOL
    fn CreateFileA(lpFileName: i8*, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: SECURITY_ATTRIBUTES *mut, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE): HANDLE
    fn CloseHandle(hObject: HANDLE): BOOL
    fn GetFileSizeEx(hFile: HANDLE, lpFileSize: u64 *mut): BOOL
    fn ReadFile(hFile: HANDLE, lpBuffer: void *mut, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: DWORD *mut, lpOverlapped: OVERLAPPED *mut): BOOL

    fn QueryPerformanceCounter(lpPerformanceCount: u64 *mut): BOOL
    fn QueryPerformanceFrequency(lpFrequency: u64 *mut): BOOL
}

user32 :: extern_mod("user32.dll") {
    fn MessageBoxA(hwnd: HWND, lpText: i8*, lpCaption: i8*, uType: u32): i32
    
}


WNDPROC :: fn(HWND, UINT, WPARAM, LPARAM) -> LRESULT
WNDCLASS :: struct {
    style: UINT
    lpfnWndProc: WNDPROC
    cbClsExtra: i32
    cbWndExtra: i32
    hInstance: HINSTANCE
    hIcon: HICON
    hCursor: HCURSOR
    hbrBackground: HBRUSH
    lpszMenuName: i8*
    lpszClassName: i8*
}

fn main_window_proc(hwnd: HWND, msg: UINT, wparam: WPARAM, lparam: LPARAM): LRESULT {
    0
}

fn main() {
    main_class :: WNDCLASS {
        style: 0
        lpfnWndProc: main_window_proc
        cbClsExtra: 0
        cbWndExtra: 0
        hInstance: NULL()
        hIcon: NULL()
        hCursor: NULL()
        hbrBackground: NULL()
        lpszMenuName: NULL() as i8*
        lpszClassName: "MAIN_WINDOW_CLASS"
    }
}